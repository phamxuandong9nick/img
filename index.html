<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SOP Creator & Image Editor</title>
    <!-- FontAwesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --primary: #2563eb;
            --primary-hover: #1d4ed8;
            --bg-dark: #1e293b;
            --bg-panel: #f8fafc;
            --border: #e2e8f0;
            --text: #334155;
            --danger: #ef4444;
            --success: #10b981;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        body {
            font-family: 'Inter', sans-serif;
            height: 100vh;
            display: flex;
            background-color: #cbd5e1;
            overflow: hidden;
            color: var(--text);
        }

        /* --- Sidebar --- */
        .sidebar {
            width: 320px;
            background: white;
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            box-shadow: 2px 0 10px rgba(0,0,0,0.05);
            z-index: 10;
        }

        .panel-section {
            padding: 12px 15px;
            border-bottom: 1px solid var(--border);
        }

        .panel-title {
            font-size: 0.8rem;
            text-transform: uppercase;
            font-weight: 700;
            color: #64748b;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        /* --- Top Icon Toolbar --- */
        .icon-toolbar {
            display: flex;
            justify-content: space-between;
            gap: 5px;
            background: #f1f5f9;
            padding: 8px;
            border-radius: 6px;
            margin-bottom: 8px;
        }

        .icon-btn {
            width: 36px;
            height: 36px;
            border: 1px solid var(--border);
            border-radius: 6px;
            background: white;
            color: var(--text);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            transition: all 0.2s;
            position: relative;
        }

        .icon-btn:hover {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        .icon-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background: #e2e8f0;
            color: #94a3b8;
        }
        
        .divider-v {
            width: 1px;
            background: #cbd5e1;
            margin: 0 2px;
        }

        /* Tools Grid */
        .tools-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 6px;
        }

        .tool-btn {
            background: var(--bg-panel);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 8px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 4px;
            transition: all 0.2s;
            color: var(--text);
            font-size: 0.75rem;
        }

        .tool-btn i { font-size: 1rem; }
        
        .tool-btn:hover { background: #e2e8f0; }
        
        .tool-btn.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        /* Inputs & Controls */
        .control-group {
            margin-bottom: 8px;
        }
        
        .control-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            margin-bottom: 6px;
        }

        label { font-size: 0.8rem; font-weight: 500; }

        input[type="color"] {
            width: 30px; height: 28px;
            border: none; cursor: pointer;
            background: none;
        }

        input[type="number"], input[type="text"] {
            padding: 5px;
            border: 1px solid var(--border);
            border-radius: 4px;
            width: 100%;
            font-size: 0.85rem;
        }

        select {
            padding: 5px;
            border: 1px solid var(--border);
            border-radius: 4px;
            width: 100%;
            font-size: 0.85rem;
            background: white;
        }

        textarea {
            padding: 6px;
            border: 1px solid var(--border);
            border-radius: 4px;
            width: 100%;
            font-size: 0.85rem;
            font-family: inherit;
            resize: vertical;
        }

        input[type="range"] { width: 100%; cursor: pointer; }

        .btn {
            padding: 6px 10px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            font-size: 0.85rem;
            transition: 0.2s;
            width: 100%;
        }
        
        .btn-sm { font-size: 0.8rem; padding: 4px 8px; width: auto; }

        .btn-primary { background: var(--primary); color: white; }
        .btn-primary:hover { background: var(--primary-hover); }
        
        .btn-danger { background: white; color: var(--danger); border: 1px solid var(--danger); }
        .btn-danger:hover { background: #fee2e2; }

        .btn-secondary { background: white; border: 1px solid var(--border); color: var(--text); }
        .btn-secondary:hover { background: var(--bg-panel); }
        
        .btn-success { background: var(--success); color: white; border: none; }
        .btn-success:hover { background: #059669; }

        /* --- Workspace --- */
        .workspace {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: auto;
            background-image: 
                linear-gradient(45deg, #e5e7eb 25%, transparent 25%), 
                linear-gradient(-45deg, #e5e7eb 25%, transparent 25%), 
                linear-gradient(45deg, transparent 75%, #e5e7eb 75%), 
                linear-gradient(-45deg, transparent 75%, #e5e7eb 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            position: relative;
            padding: 40px;
        }

        .canvas-container-shadow {
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            background: white;
        }

        /* --- Toast Notification --- */
        #toast-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .toast {
            background: #1e293b;
            color: white;
            padding: 12px 20px;
            border-radius: 6px;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            animation: slideIn 0.3s ease-out forwards;
            min-width: 250px;
        }
        
        .toast.success i { color: #4ade80; }
        .toast.info i { color: #60a5fa; }
        .toast.error i { color: #ef4444; }

        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        @keyframes fadeOut {
            to { opacity: 0; transform: translateY(10px); }
        }

        /* --- Modal for Manual Copy --- */
        .modal-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
        }
        
        .modal-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }

        .modal-content {
            background: white;
            padding: 20px;
            border-radius: 8px;
            max-width: 90%;
            max-height: 90%;
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
            text-align: center;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .modal-content img {
            max-width: 100%;
            max-height: 60vh;
            border: 1px solid #ddd;
            display: block;
            margin: 0 auto;
        }

        /* Utility classes */
        .w-half { width: 48%; }
        .hidden { display: none; }
        .file-info { font-size: 0.75rem; color: #64748b; background: #f1f5f9; padding: 4px; border-radius: 4px; margin-top: 5px; }
        
        .checkbox-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.8rem;
            cursor: pointer;
        }
    </style>
    <!-- Fabric JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>
    <!-- BWIP-JS for Barcode/QR -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/bwip-js/3.4.3/bwip-js-min.js"></script>
</head>
<body>

    <!-- Sidebar -->
    <div class="sidebar">
        
        <!-- TOP SECTION: Toolbar + Config + Upload -->
        <div class="panel-section">
            <div class="icon-toolbar">
                <button class="icon-btn" id="copyClipboard" title="Copy to Clipboard (PNG)"><i class="fa-regular fa-copy"></i></button>
                <button class="icon-btn" id="copyMarkdown" title="Copy Markdown Base64 (PNG)"><i class="fa-brands fa-markdown"></i></button>
                <button class="icon-btn" id="downloadBtn" title="Tải ảnh xuống (.png)"><i class="fa-solid fa-download"></i></button>
                
                <div class="divider-v"></div>
                
                <button class="icon-btn" id="undoBtn" title="Hoàn tác (Ctrl+Z)" disabled><i class="fa-solid fa-rotate-left"></i></button>
                <button class="icon-btn" id="redoBtn" title="Làm lại (Ctrl+Y)" disabled><i class="fa-solid fa-rotate-right"></i></button>
            </div>
            
            <!-- Quality Config (Moved Up) -->
            <div class="control-group" style="border-bottom: 1px dashed #e2e8f0; padding-bottom: 8px; margin-bottom: 8px;">
                <div class="control-row">
                    <label style="font-size: 0.75rem;">Định dạng xuất: PNG (Lossless)</label>
                </div>
                <input type="range" id="qualityRange" min="0.1" max="1.0" step="0.1" value="1.0" disabled style="opacity: 0.5;">
                <div class="file-info" id="fileSizeInfo">Size: - | PNG</div>
            </div>

            <!-- Compact Upload & Canvas Info -->
            <div class="control-row" style="margin-bottom: 10px;">
                <button class="btn btn-primary btn-sm" onclick="document.getElementById('fileInput').click()" title="Tải ảnh lên">
                    <i class="fa-solid fa-upload"></i> Upload
                </button>
                <input type="file" id="fileInput" accept="image/*" class="hidden">
                <span style="font-size: 0.75rem; color: #64748b;">(hoặc Ctrl+V)</span>
            </div>

            <div class="control-row">
                <div class="w-half">
                    <label>Rộng</label>
                    <input type="number" id="canvasWidth" value="800">
                </div>
                <div class="w-half">
                    <label>Cao</label>
                    <input type="number" id="canvasHeight" value="600">
                </div>
            </div>
            <div class="control-row">
                <button class="btn btn-secondary w-half" id="resizeBtn" style="font-size: 0.75rem;">Resize</button>
                <button class="btn btn-secondary w-half" id="fitCanvasBtn" style="font-size: 0.75rem;" title="Cắt canvas vừa khít nội dung">Fit Content</button>
            </div>
            <button class="btn btn-danger" id="clearBtn" style="font-size: 0.75rem;"><i class="fa-solid fa-trash"></i> Reset All</button>
        </div>

        <!-- Tools Section -->
        <div class="panel-section">
            <div class="panel-title"><i class="fa-solid fa-pen-ruler"></i> Công cụ vẽ</div>
            <div class="tools-grid">
                <div class="tool-btn active" data-tool="select" title="Chọn & Di chuyển (V)">
                    <i class="fa-solid fa-arrow-pointer"></i> <span>Chọn</span>
                </div>
                <div class="tool-btn" data-tool="rect" title="Hình chữ nhật (R)">
                    <i class="fa-regular fa-square"></i> <span>Khung</span>
                </div>
                <div class="tool-btn" data-tool="circle" title="Hình tròn (C)">
                    <i class="fa-regular fa-circle"></i> <span>Tròn</span>
                </div>
                <div class="tool-btn" data-tool="arrow" title="Mũi tên (A)">
                    <i class="fa-solid fa-arrow-right-long"></i> <span>Mũi tên</span>
                </div>
                <div class="tool-btn" data-tool="text" title="Văn bản (T)">
                    <i class="fa-solid fa-font"></i> <span>Chữ</span>
                </div>
                <div class="tool-btn" data-tool="stamp" title="Đánh số thứ tự (S)">
                    <i class="fa-solid fa-stamp"></i> <span>Stamp</span>
                </div>
                <!-- New Barcode/QR Tool -->
                <div class="tool-btn" data-tool="qrcode" title="Mã vạch / QR Code">
                    <i class="fa-solid fa-qrcode"></i> <span>QR/Code</span>
                </div>
            </div>
            
            <!-- Stamp Settings -->
            <div id="stampSettings" class="control-group" style="margin-top: 10px; display:none; background: #fff7ed; padding: 10px; border-radius: 6px; border: 1px solid #ffedd5;">
                <label style="color: #c2410c;">Số bắt đầu:</label>
                <div class="control-row">
                    <input type="number" id="stampCount" value="1" min="1">
                    <button class="btn btn-secondary btn-sm" onclick="resetStamp()">Reset</button>
                </div>
            </div>

            <!-- QR/Barcode Settings (New) -->
            <div id="qrSettings" class="control-group" style="margin-top: 10px; display:none; background: #f0fdf4; padding: 10px; border-radius: 6px; border: 1px solid #bbf7d0;">
                <label style="color: #15803d; font-weight:bold;">Tạo Mã QR/Barcode:</label>
                <div style="margin-bottom: 5px;">
                    <select id="bcType">
                        <option value="qrcode">QR Code</option>
                        <option value="code128">Code 128 (Barcode)</option>
                        <option value="ean13">EAN-13</option>
                    </select>
                </div>
                <div style="margin-bottom: 5px;">
                    <input type="text" id="bcText" placeholder="Nhập nội dung mã..." value="SOP-123">
                </div>
                <button class="btn btn-success btn-sm" id="generateBcBtn" style="width: 100%;">
                    <i class="fa-solid fa-plus"></i> Chèn vào Canvas
                </button>
            </div>
        </div>

        <!-- Properties Section -->
        <div class="panel-section">
            <div class="panel-title"><i class="fa-solid fa-sliders"></i> Thuộc tính</div>
            
            <!-- Nút Xóa Đối Tượng -->
            <div class="control-group">
                <button class="btn btn-danger" id="deleteObjBtn" title="Xóa đối tượng đang chọn (Delete)">
                    <i class="fa-solid fa-eraser"></i> Xóa đối tượng đang chọn
                </button>
            </div>

             <!-- TEXT EDITOR -->
             <div class="control-group hidden" id="textEditorPanel" style="background: #e0f2fe; padding: 10px; border-radius: 6px; margin-bottom: 10px;">
                <label style="color: #0369a1; display: block; margin-bottom: 5px;">
                    <i class="fa-solid fa-keyboard"></i> Sửa văn bản:
                </label>
                <textarea id="textEditorInput" rows="3"></textarea>
            </div>

            <!-- OBJECT SIZE EDITOR -->
            <div class="control-group hidden" id="objectSizeSettings" style="background: #eff6ff; padding: 10px; border-radius: 6px; margin-bottom: 10px;">
                <label style="color: #1e40af; display: block; margin-bottom: 5px;">Kích thước:</label>
                <div class="control-row">
                    <div class="w-half">
                        <label style="font-size: 0.7rem;">Rộng</label>
                        <input type="number" id="objWidth">
                    </div>
                    <div class="w-half">
                        <label style="font-size: 0.7rem;">Cao</label>
                        <input type="number" id="objHeight">
                    </div>
                </div>
                <label class="checkbox-wrapper">
                    <input type="checkbox" id="lockRatio" checked> Khóa tỷ lệ
                </label>
            </div>

            <div class="control-group">
                <label>Màu viền (Stroke)</label>
                <div class="control-row">
                    <input type="color" id="strokeColor" value="#ef4444">
                    <input type="range" id="strokeWidth" min="1" max="20" value="3" style="width: 60%">
                    <span id="strokeWidthVal" style="font-size: 0.8rem; width: 20px;">3</span>
                </div>
            </div>

            <div class="control-group">
                <label>Màu nền (Fill)</label>
                <div class="control-row">
                    <input type="color" id="fillColor" value="#ef4444" disabled>
                    <label class="checkbox-wrapper">
                        <input type="checkbox" id="transparentFill" checked> Trong suốt
                    </label>
                </div>
            </div>
        </div>

        <!-- Layers & Transform -->
        <div class="panel-section">
            <div class="panel-title"><i class="fa-solid fa-layer-group"></i> Lớp & Biến đổi</div>
            <div class="control-row">
                <button class="btn btn-secondary w-half" id="bringFront" title="Lên trên cùng"><i class="fa-solid fa-arrow-up"></i> Lên</button>
                <button class="btn btn-secondary w-half" id="sendBack" title="Xuống dưới cùng"><i class="fa-solid fa-arrow-down"></i> Xuống</button>
            </div>
            <div class="control-row">
                <button class="btn btn-secondary w-half" id="rotateLeft"><i class="fa-solid fa-rotate-left"></i> -90°</button>
                <button class="btn btn-secondary w-half" id="rotateRight"><i class="fa-solid fa-rotate-right"></i> +90°</button>
            </div>
        </div>
    </div>

    <!-- Workspace -->
    <div class="workspace" id="workspace">
        <div class="canvas-container-shadow">
            <canvas id="c"></canvas>
        </div>
    </div>

    <!-- Manual Copy Modal -->
    <div id="manualCopyModal" class="modal-overlay">
        <div class="modal-content">
            <h3 style="color: var(--text);">Sao chép thủ công</h3>
            <p style="font-size: 0.9rem; color: #64748b;">Trình duyệt chặn Copy tự động. Bạn hãy:<br><b>Click chuột phải vào ảnh dưới ➡ Chọn "Sao chép hình ảnh" (Copy Image)</b></p>
            <img id="manualCopyImg" src="" alt="SOP Result">
            <button class="btn btn-secondary" onclick="document.getElementById('manualCopyModal').classList.remove('active')">Đóng</button>
        </div>
    </div>

    <!-- Toast Container -->
    <div id="toast-container"></div>

    <script>
        // --- 1. INITIALIZATION ---
        const initWidth = 800;
        const initHeight = 600;
        
        const canvas = new fabric.Canvas('c', {
            width: initWidth,
            height: initHeight,
            backgroundColor: '#ffffff', // Explicitly set white bg
            preserveObjectStacking: true 
        });

        // Global State
        let currentMode = 'select';
        let isDrawing = false;
        let origX, origY;
        let activeObj;
        let stampCount = 1;

        // UNDO/REDO State
        const history = [];
        const historyRedo = [];
        let isHistoryLocked = false;
        const MAX_HISTORY = 20;

        // DOM Elements
        const els = {
            width: document.getElementById('canvasWidth'),
            height: document.getElementById('canvasHeight'),
            strokeColor: document.getElementById('strokeColor'),
            strokeWidth: document.getElementById('strokeWidth'),
            strokeWidthVal: document.getElementById('strokeWidthVal'),
            fillColor: document.getElementById('fillColor'),
            transparentFill: document.getElementById('transparentFill'),
            stampCount: document.getElementById('stampCount'),
            quality: document.getElementById('qualityRange'),
            qualityVal: document.getElementById('qualityVal'),
            fileInfo: document.getElementById('fileSizeInfo'),
            stampSettings: document.getElementById('stampSettings'),
            objSizePanel: document.getElementById('objectSizeSettings'),
            objWidth: document.getElementById('objWidth'),
            objHeight: document.getElementById('objHeight'),
            lockRatio: document.getElementById('lockRatio'),
            undoBtn: document.getElementById('undoBtn'),
            redoBtn: document.getElementById('redoBtn'),
            deleteObjBtn: document.getElementById('deleteObjBtn'),
            fitCanvasBtn: document.getElementById('fitCanvasBtn'),
            // Text Editor Elements
            textEditorPanel: document.getElementById('textEditorPanel'),
            textEditorInput: document.getElementById('textEditorInput'),
            // Modal Elements
            modal: document.getElementById('manualCopyModal'),
            modalImg: document.getElementById('manualCopyImg'),
            // QR Settings
            qrSettings: document.getElementById('qrSettings'),
            bcType: document.getElementById('bcType'),
            bcText: document.getElementById('bcText'),
            generateBcBtn: document.getElementById('generateBcBtn')
        };

        // --- 2. UNDO / REDO SYSTEM ---

        function saveHistory() {
            if (isHistoryLocked) return;
            if (history.length >= MAX_HISTORY) history.shift();
            history.push(JSON.stringify(canvas));
            historyRedo.length = 0;
            updateHistoryButtons();
        }

        function updateHistoryButtons() {
            els.undoBtn.disabled = history.length === 0;
            els.redoBtn.disabled = historyRedo.length === 0;
        }

        canvas.on('object:added', () => saveHistory());
        canvas.on('object:modified', () => saveHistory());
        canvas.on('object:removed', () => saveHistory());

        function undo() {
            if (history.length === 0) return;
            isHistoryLocked = true;
            historyRedo.push(JSON.stringify(canvas));
            const prevState = history.pop();
            canvas.loadFromJSON(prevState, () => {
                canvas.renderAll();
                isHistoryLocked = false;
                updateHistoryButtons();
                updateFileSizeInfo();
            });
        }

        function redo() {
            if (historyRedo.length === 0) return;
            isHistoryLocked = true;
            history.push(JSON.stringify(canvas));
            const nextState = historyRedo.pop();
            canvas.loadFromJSON(nextState, () => {
                canvas.renderAll();
                isHistoryLocked = false;
                updateHistoryButtons();
                updateFileSizeInfo();
            });
        }

        els.undoBtn.addEventListener('click', undo);
        els.redoBtn.addEventListener('click', redo);

        // --- 3. CANVAS ACTIONS & RESIZE ---

        function resizeCanvas(w, h) {
            saveHistory(); 
            const newW = parseInt(w);
            const newH = parseInt(h);
            
            canvas.setWidth(newW);
            canvas.setHeight(newH);
            
            // Fix trắng màn hình: Reset viewport để chắc chắn không bị zoom/pan sai vị trí
            canvas.setViewportTransform([1, 0, 0, 1, 0, 0]); 
            canvas.calcOffset(); // Recalculate offsets from DOM
            
            els.width.value = newW;
            els.height.value = newH;
            
            canvas.requestRenderAll();
            updateFileSizeInfo();
        }

        document.getElementById('resizeBtn').addEventListener('click', () => {
            resizeCanvas(els.width.value, els.height.value);
            showToast('Đã cập nhật kích thước Canvas', 'info');
        });

        // Fit Canvas to Content
        els.fitCanvasBtn.addEventListener('click', () => {
            const objects = canvas.getObjects();
            if (objects.length === 0) {
                showToast('Không có đối tượng nào để fit', 'info');
                return;
            }

            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            objects.forEach(obj => {
                const br = obj.getBoundingRect();
                if (br.left < minX) minX = br.left;
                if (br.top < minY) minY = br.top;
                if (br.left + br.width > maxX) maxX = br.left + br.width;
                if (br.top + br.height > maxY) maxY = br.top + br.height;
            });

            const padding = 20;
            const newWidth = (maxX - minX) + padding * 2;
            const newHeight = (maxY - minY) + padding * 2;

            saveHistory();

            objects.forEach(obj => {
                obj.set({
                    left: obj.left - minX + padding,
                    top: obj.top - minY + padding
                });
                obj.setCoords();
            });

            resizeCanvas(newWidth, newHeight);
            canvas.renderAll();
            showToast('Đã fit Canvas vừa nội dung', 'success');
        });

        document.getElementById('clearBtn').addEventListener('click', () => {
            if(confirm('Bạn có chắc muốn xóa toàn bộ không?')) {
                saveHistory();
                canvas.clear();
                canvas.setBackgroundColor('#ffffff', canvas.renderAll.bind(canvas));
                resizeCanvas(initWidth, initHeight);
                stampCount = 1;
                els.stampCount.value = 1;
                showToast('Đã reset Canvas', 'info');
            }
        });

        els.deleteObjBtn.addEventListener('click', () => {
            const active = canvas.getActiveObjects();
            if (active.length) {
                canvas.remove(...active);
                canvas.discardActiveObject();
                showToast('Đã xóa đối tượng', 'info');
            } else {
                showToast('Chưa chọn đối tượng nào', 'info');
            }
        });

        // --- 4. IMAGE INPUT LOGIC ---

        document.getElementById('fileInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) handleImageFile(file);
            e.target.value = '';
        });

        window.addEventListener('paste', function(e) {
            const items = (e.clipboardData || e.originalEvent.clipboardData).items;
            let blob = null;
            for (let i = 0; i < items.length; i++) {
                if (items[i].type.indexOf('image') !== -1) {
                    blob = items[i].getAsFile();
                    break;
                }
            }
            if (blob) {
                handleImageFile(blob);
                e.preventDefault();
            }
        });

        function handleImageFile(file) {
            const reader = new FileReader();
            reader.onload = function(f) {
                const data = f.target.result;
                fabric.Image.fromURL(data, function(img) {
                    const isEmpty = canvas.getObjects().length === 0;

                    if (isEmpty) {
                        const w = img.width;
                        const h = img.height;
                        resizeCanvas(w, h);
                        img.set({ left: 0, top: 0, originX: 'left', originY: 'top', selectable: true });
                        canvas.add(img);
                        canvas.setActiveObject(img);
                        canvas.renderAll();
                        showToast('Đã dán ảnh.', 'success');
                    } else {
                        const maxWidth = canvas.getWidth() * 0.8;
                        const maxHeight = canvas.getHeight() * 0.8;
                        if (img.width > maxWidth || img.height > maxHeight) {
                            img.scaleToWidth(maxWidth);
                        }
                        img.set({ left: canvas.getWidth()/2, top: canvas.getHeight()/2, originX: 'center', originY: 'center' });
                        canvas.add(img);
                        canvas.setActiveObject(img);
                        canvas.requestRenderAll();
                        showToast('Đã thêm ảnh vào lớp mới', 'success');
                    }
                    updateFileSizeInfo();
                });
            };
            reader.readAsDataURL(file);
        }

        // --- 5. TOOLBAR & SHORTCUTS ---

        document.querySelectorAll('.tool-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentMode = btn.getAttribute('data-tool');
                
                // Toggle Settings Panels
                els.stampSettings.style.display = (currentMode === 'stamp') ? 'block' : 'none';
                els.qrSettings.style.display = (currentMode === 'qrcode') ? 'block' : 'none';

                if (currentMode === 'select') {
                    canvas.selection = true;
                    canvas.defaultCursor = 'default';
                    canvas.forEachObject(o => o.selectable = true);
                } else if (currentMode === 'qrcode') {
                    // QR mode is strictly an insertion mode, switch back to select logic for interactions
                    canvas.selection = true;
                    canvas.defaultCursor = 'default';
                    // We don't disable selection here so users can move existing objects while panel is open
                } else {
                    canvas.selection = false;
                    canvas.defaultCursor = 'crosshair';
                    canvas.discardActiveObject();
                    canvas.requestRenderAll();
                    canvas.forEachObject(o => o.selectable = false);
                }
            });
        });

        window.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') return; 

            if (e.ctrlKey && e.key.toLowerCase() === 'z') { e.preventDefault(); undo(); return; }
            if (e.ctrlKey && e.key.toLowerCase() === 'y') { e.preventDefault(); redo(); return; }

            switch(e.key.toLowerCase()) {
                case 'v': clickTool('select'); break;
                case 'r': clickTool('rect'); break;
                case 'c': clickTool('circle'); break;
                case 'a': clickTool('arrow'); break;
                case 't': clickTool('text'); break;
                case 's': clickTool('stamp'); break;
                case 'delete': els.deleteObjBtn.click(); break;
            }
        });

        function clickTool(name) {
            document.querySelector(`.tool-btn[data-tool="${name}"]`).click();
        }

        // --- 6. DRAWING LOGIC ---

        canvas.on('mouse:down', function(o) {
            if (currentMode === 'select' || currentMode === 'qrcode') return;

            isDrawing = true;
            const pointer = canvas.getPointer(o.e);
            origX = pointer.x;
            origY = pointer.y;

            const commonProps = {
                left: origX, top: origY,
                originX: 'left', originY: 'top',
                fill: els.transparentFill.checked ? 'transparent' : els.fillColor.value,
                stroke: els.strokeColor.value,
                strokeWidth: parseInt(els.strokeWidth.value),
                transparentCorners: false,
                cornerColor: '#2563eb',
                cornerSize: 10
            };

            if (currentMode === 'rect') {
                activeObj = new fabric.Rect({ ...commonProps, width: 0, height: 0 });
                canvas.add(activeObj);
            } 
            else if (currentMode === 'circle') {
                activeObj = new fabric.Ellipse({ ...commonProps, rx: 0, ry: 0 });
                canvas.add(activeObj);
            }
            else if (currentMode === 'arrow') {
                activeObj = new fabric.Line([origX, origY, origX, origY], {
                    stroke: els.strokeColor.value,
                    strokeWidth: parseInt(els.strokeWidth.value),
                    selectable: false
                });
                canvas.add(activeObj);
            }
            else if (currentMode === 'text') {
                const text = new fabric.IText('Text', {
                    left: origX, top: origY,
                    fontFamily: 'Inter',
                    fill: els.strokeColor.value,
                    fontSize: 24
                });
                canvas.add(text);
                canvas.setActiveObject(text);
                text.enterEditing();
                isDrawing = false;
                clickTool('select');
            }
            else if (currentMode === 'stamp') {
                createStamp(origX, origY);
                isDrawing = false;
            }
        });

        canvas.on('mouse:move', function(o) {
            if (!isDrawing) return;
            const pointer = canvas.getPointer(o.e);

            if (currentMode === 'rect') {
                if(origX > pointer.x) activeObj.set({ left: Math.abs(pointer.x) });
                if(origY > pointer.y) activeObj.set({ top: Math.abs(pointer.y) });
                activeObj.set({ width: Math.abs(origX - pointer.x) });
                activeObj.set({ height: Math.abs(origY - pointer.y) });
            } 
            else if (currentMode === 'circle') {
                const rx = Math.abs(origX - pointer.x) / 2;
                const ry = Math.abs(origY - pointer.y) / 2;
                if(origX > pointer.x) activeObj.set({ left: Math.abs(pointer.x) });
                if(origY > pointer.y) activeObj.set({ top: Math.abs(pointer.y) });
                activeObj.set({ rx: rx, ry: ry });
            }
            else if (currentMode === 'arrow') {
                activeObj.set({ x2: pointer.x, y2: pointer.y });
            }
            canvas.renderAll();
        });

        canvas.on('mouse:up', function(o) {
            if (!isDrawing) return;
            isDrawing = false;

            if (currentMode === 'arrow') {
                const line = activeObj;
                canvas.remove(line);
                createArrow(line.x1, line.y1, line.x2, line.y2);
            }
            
            if (activeObj) activeObj.setCoords();

            if (currentMode !== 'stamp') {
                clickTool('select');
                if(activeObj && currentMode !== 'arrow') canvas.setActiveObject(activeObj);
            }
            activeObj = null;
        });

        // --- 7. BARCODE / QR GENERATION LOGIC (NEW) ---
        
        els.generateBcBtn.addEventListener('click', () => {
            const text = els.bcText.value.trim();
            const type = els.bcType.value;
            
            if(!text) {
                showToast('Vui lòng nhập nội dung!', 'error');
                return;
            }

            try {
                // Create a temporary canvas for bwip-js to render
                let canvasTmp = document.createElement('canvas');
                
                let opts = {
                    bcid: type,       // Barcode type
                    text: text,       // Text to encode
                    scale: 3,         // 3x scaling factor
                    height: 10,       // Bar height, in millimeters
                    includetext: true,// Show human-readable text
                    textxalign: 'center',
                };

                // Adjust options for QR Code
                if(type === 'qrcode') {
                    opts.height = 50; // Width/Height are same for QR
                    opts.includetext = false;
                }

                bwipjs.toCanvas(canvasTmp, opts);
                
                // Convert to Fabric Image
                const imgUrl = canvasTmp.toDataURL('image/png');
                fabric.Image.fromURL(imgUrl, function(img) {
                    img.set({
                        left: canvas.getWidth() / 2,
                        top: canvas.getHeight() / 2,
                        originX: 'center',
                        originY: 'center',
                        selectable: true
                    });
                    
                    // Scale down if too big
                    if(img.width > 300) img.scaleToWidth(300);
                    
                    canvas.add(img);
                    canvas.setActiveObject(img);
                    saveHistory();
                    showToast('Đã chèn mã thành công!', 'success');
                    
                    // Switch back to select tool
                    clickTool('select');
                });

            } catch (e) {
                console.error(e);
                showToast('Lỗi tạo mã: ' + e.message, 'error');
            }
        });

        // --- 8. SPECIAL OBJECT LOGIC ---

        function createArrow(x1, y1, x2, y2) {
            const headLength = 15;
            const angle = Math.atan2(y2 - y1, x2 - x1);
            const line = new fabric.Line([x1, y1, x2, y2], {
                stroke: els.strokeColor.value,
                strokeWidth: parseInt(els.strokeWidth.value),
                originX: 'center', originY: 'center'
            });
            x2 = x2 - (headLength/2) * Math.cos(angle);
            y2 = y2 - (headLength/2) * Math.sin(angle);
            const arrowHead = new fabric.Triangle({
                left: x2, top: y2,
                originX: 'center', originY: 'center',
                angle: (angle * 180 / Math.PI) + 90,
                width: headLength, height: headLength + 5,
                fill: els.strokeColor.value
            });
            const group = new fabric.Group([line, arrowHead], { selectable: true });
            canvas.add(group);
            canvas.setActiveObject(group);
            canvas.renderAll();
        }

        function createStamp(x, y) {
            const num = stampCount;
            const circle = new fabric.Circle({
                radius: 15, fill: els.strokeColor.value,
                stroke: '#ffffff', strokeWidth: 2,
                originX: 'center', originY: 'center'
            });
            const text = new fabric.Text(num.toString(), {
                fontSize: 18, fontFamily: 'Inter',
                fill: '#fff', fontWeight: 'bold',
                originX: 'center', originY: 'center'
            });
            const group = new fabric.Group([circle, text], {
                left: x, top: y,
                originX: 'center', originY: 'center', selectable: true
            });
            canvas.add(group);
            stampCount++;
            els.stampCount.value = stampCount;
        }

        function resetStamp() {
            stampCount = parseInt(els.stampCount.value) || 1;
            showToast(`Stamp bắt đầu từ số ${stampCount}`, 'info');
        }
        els.stampCount.addEventListener('change', () => stampCount = parseInt(els.stampCount.value));

        // --- 9. PROPERTIES & UPDATE LOGIC ---

        function updateActiveObject(prop, value) {
            const active = canvas.getActiveObject();
            if (!active) return;

            if (active.type === 'activeSelection') {
                active.getObjects().forEach(obj => modifyObject(obj, prop, value));
            } else {
                modifyObject(active, prop, value);
            }
            canvas.requestRenderAll();
        }

        els.strokeWidth.addEventListener('change', saveHistory);
        els.strokeColor.addEventListener('change', saveHistory);
        els.fillColor.addEventListener('change', saveHistory);

        function modifyObject(obj, prop, value) {
            if (obj.type === 'group') {
                obj.getObjects().forEach(child => {
                    if (child.type === 'text' || child.type === 'i-text') {
                         if (prop === 'fill') return; 
                    } else {
                         if (prop === 'stroke') {
                             if(child.type === 'triangle') child.set('fill', value); 
                             else if(child.type === 'circle') child.set('fill', value); 
                             else child.set('stroke', value);
                         }
                         if (prop === 'fill' && child.type === 'circle') {
                             child.set('fill', value);
                         }
                    }
                });
                return;
            }

            if (prop === 'fill') {
                if (obj.type === 'i-text') obj.set('fill', value);
                else obj.set('fill', value);
            }
            else if (prop === 'stroke') {
                if (obj.type === 'i-text') obj.set('fill', value);
                else obj.set('stroke', value);
            }
            else if (prop === 'strokeWidth') {
                if (obj.type !== 'i-text') obj.set('strokeWidth', parseInt(value));
            }
        }

        els.strokeColor.addEventListener('input', (e) => updateActiveObject('stroke', e.target.value));
        
        els.strokeWidth.addEventListener('input', (e) => {
            els.strokeWidthVal.innerText = e.target.value;
            updateActiveObject('strokeWidth', e.target.value);
        });

        els.fillColor.addEventListener('input', (e) => {
            if (!els.transparentFill.checked) updateActiveObject('fill', e.target.value);
        });

        els.transparentFill.addEventListener('change', (e) => {
            els.fillColor.disabled = e.target.checked;
            const val = e.target.checked ? 'transparent' : els.fillColor.value;
            updateActiveObject('fill', val);
            saveHistory();
        });

        // --- TEXT EDITOR LOGIC (NEW) ---
        els.textEditorInput.addEventListener('input', function() {
            const active = canvas.getActiveObject();
            if (active && (active.type === 'i-text' || active.type === 'text')) {
                active.set('text', this.value);
                canvas.requestRenderAll();
            }
        });
        
        els.textEditorInput.addEventListener('change', function() {
            saveHistory();
        });

        canvas.on('text:changed', function(e) {
            if (e.target) {
                els.textEditorInput.value = e.target.text;
            }
        });

        // --- OBJECT SIZE INPUT LOGIC ---

        function updateContextSettings() {
            const active = canvas.getActiveObject();
            
            // Text Editor Handling
            if (active && (active.type === 'i-text' || active.type === 'text')) {
                els.textEditorPanel.classList.remove('hidden');
                els.textEditorInput.value = active.text;
            } else {
                els.textEditorPanel.classList.add('hidden');
            }

            // Object Size Handling
            if (active) {
                els.objSizePanel.classList.remove('hidden');
                els.objWidth.value = Math.round(active.getScaledWidth());
                els.objHeight.value = Math.round(active.getScaledHeight());
            } else {
                els.objSizePanel.classList.add('hidden');
            }
        }
        
        els.objWidth.addEventListener('change', function() {
            const active = canvas.getActiveObject();
            if(!active) return;
            const newW = parseInt(this.value);
            const scaleX = newW / active.width;
            
            if (els.lockRatio.checked) {
                 const ratio = active.scaleY / active.scaleX;
                 active.set('scaleX', scaleX);
                 active.set('scaleY', scaleX * ratio);
                 els.objHeight.value = Math.round(active.getScaledHeight());
            } else {
                 active.set('scaleX', scaleX);
            }
            active.setCoords();
            canvas.requestRenderAll();
            saveHistory();
            updateFileSizeInfo();
        });

        els.objHeight.addEventListener('change', function() {
            const active = canvas.getActiveObject();
            if(!active) return;
            const newH = parseInt(this.value);
            const scaleY = newH / active.height;
            
            if (els.lockRatio.checked) {
                 const ratio = active.scaleX / active.scaleY;
                 active.set('scaleY', scaleY);
                 active.set('scaleX', scaleY * ratio);
                 els.objWidth.value = Math.round(active.getScaledWidth());
            } else {
                 active.set('scaleY', scaleY);
            }
            active.setCoords();
            canvas.requestRenderAll();
            saveHistory();
            updateFileSizeInfo();
        });

        canvas.on('selection:created', (e) => { updatePropsFromSelection(e); updateContextSettings(); });
        canvas.on('selection:updated', (e) => { updatePropsFromSelection(e); updateContextSettings(); });
        canvas.on('selection:cleared', () => { 
            els.objSizePanel.classList.add('hidden'); 
            els.textEditorPanel.classList.add('hidden');
        });
        canvas.on('object:modified', updateContextSettings);

        function updatePropsFromSelection(e) {
            const obj = e.selected[0];
            if (!obj) return;
            if (obj.stroke && obj.stroke !== 'transparent') els.strokeColor.value = obj.stroke;
            if (obj.strokeWidth) {
                els.strokeWidth.value = obj.strokeWidth;
                els.strokeWidthVal.innerText = obj.strokeWidth;
            }
            if (obj.fill === 'transparent') {
                els.transparentFill.checked = true;
                els.fillColor.disabled = true;
            } else if (typeof obj.fill === 'string' && obj.fill.startsWith('#')) {
                els.transparentFill.checked = false;
                els.fillColor.disabled = false;
                els.fillColor.value = obj.fill;
            }
        }

        // --- 10. LAYERS & EXPORT ---

        document.getElementById('bringFront').addEventListener('click', () => {
            const active = canvas.getActiveObject();
            if (active) { active.bringForward(); canvas.discardActiveObject(); canvas.renderAll(); saveHistory(); }
        });
        document.getElementById('sendBack').addEventListener('click', () => {
            const active = canvas.getActiveObject();
            if (active) { active.sendBackwards(); canvas.discardActiveObject(); canvas.renderAll(); saveHistory(); }
        });
        document.getElementById('rotateLeft').addEventListener('click', () => {
            const active = canvas.getActiveObject();
            if (active) { active.rotate((active.angle || 0) - 90); canvas.requestRenderAll(); saveHistory(); }
        });
        document.getElementById('rotateRight').addEventListener('click', () => {
            const active = canvas.getActiveObject();
            if (active) { active.rotate((active.angle || 0) + 90); canvas.requestRenderAll(); saveHistory(); }
        });

        // --- FIXED EXPORT LOGIC FOR CORRECT SIZING ---
        function getExportData(callback) {
            const quality = parseFloat(els.quality.value);
            const prevBg = canvas.backgroundColor;
            if (!prevBg && !canvas.backgroundImage) canvas.backgroundColor = '#ffffff';
            
            // Render all to verify
            canvas.renderAll();
            
            // FIX: Use toDataURL with multiplier: 1 first to get correct logical size,
            // then convert to Blob. This avoids Retina scaling issues with toBlob() on canvas element.
            const dataURL = canvas.toDataURL({
                format: 'png',
                multiplier: 1, 
                quality: 1 // PNG is lossless
            });

            // Convert Base64 to Blob
            fetch(dataURL)
                .then(res => res.blob())
                .then(blob => {
                    // restore bg if needed (though we just read it)
                    canvas.backgroundColor = prevBg;
                    callback(blob);
                });
        }

        function updateFileSizeInfo() {
            // PNG size estimation is difficult without creating the blob
            const w = canvas.getWidth();
            const h = canvas.getHeight();
            
            // Just show dimensions for PNG as compression varies heavily
            els.fileInfo.innerHTML = `Size: ${w}x${h}px | PNG`;
        }

        els.quality.addEventListener('input', updateFileSizeInfo);
        canvas.on('object:modified', updateFileSizeInfo);
        canvas.on('object:added', updateFileSizeInfo);

        // --- NEW COPY FUNCTION ---
        document.getElementById('copyClipboard').addEventListener('click', () => {
            getExportData(async function(blob) {
                if (!blob) {
                    showToast('Lỗi tạo ảnh', 'error');
                    return;
                }
                
                try {
                    // Method 1: Modern Clipboard API
                    const item = new ClipboardItem({ [blob.type]: blob });
                    await navigator.clipboard.write([item]);
                    showToast('Đã copy ảnh vào Clipboard!', 'success');
                } catch (err) {
                    console.warn('Clipboard API failed, showing manual modal...', err);
                    
                    // Method 2: Manual Fallback
                    const url = URL.createObjectURL(blob);
                    els.modalImg.src = url;
                    els.modal.classList.add('active');
                }
            });
        });

        document.getElementById('copyMarkdown').addEventListener('click', () => {
            // Use PNG format
            const dataURL = canvas.toDataURL({ format: 'png', multiplier: 1 });
            
            const md = `![SOP Image](${dataURL})`;
            const textArea = document.createElement("textarea");
            textArea.value = md;
            document.body.appendChild(textArea);
            textArea.select();
            document.execCommand('copy');
            document.body.removeChild(textArea);
            showToast('Đã copy mã Markdown (PNG)!', 'success');
        });

        document.getElementById('downloadBtn').addEventListener('click', () => {
            getExportData(function(blob) {
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                // Change extension to .png
                link.download = `sop-image-${Date.now()}.png`;
                link.href = url;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                showToast('Đang tải xuống...', 'success');
            });
        });

        function showToast(msg, type='info') {
            const container = document.getElementById('toast-container');
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            let icon = '<i class="fa-solid fa-info-circle"></i>';
            if (type === 'success') icon = '<i class="fa-solid fa-check-circle"></i>';
            if (type === 'error') icon = '<i class="fa-solid fa-exclamation-circle"></i>';
            
            toast.innerHTML = `${icon} <span>${msg}</span>`;
            container.appendChild(toast);
            setTimeout(() => {
                toast.style.animation = 'fadeOut 0.3s forwards';
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }

        // Init
        saveHistory();
        updateFileSizeInfo();
        showToast('Sẵn sàng! Dán ảnh (Ctrl+V) để bắt đầu.', 'info');

    </script>
</body>
</html>
