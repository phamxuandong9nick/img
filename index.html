<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chuyển Ảnh sang Base64 & Chú Thích</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Tùy chỉnh thanh trượt */
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
            margin-top: -8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #e5e7eb;
            border-radius: 2px;
        }
        .preview-pattern {
            background-color: #ffffff;
            background-image: radial-gradient(#cbd5e1 1px, transparent 1px);
            background-size: 10px 10px;
        }
        canvas {
            touch-action: none; /* Ngăn cuộn trang khi vẽ trên mobile */
        }
        .tool-btn.active {
            background-color: #dbeafe; /* bg-blue-100 */
            color: #1d4ed8; /* text-blue-700 */
            ring-width: 2px;
            ring-color: #3b82f6; /* ring-blue-500 */
            border-color: transparent;
        }
    </style>
</head>
<body class="bg-gray-50 text-gray-800 min-h-screen font-sans">

    <div class="max-w-6xl mx-auto p-4 md:p-8">
        
        <!-- Header -->
        <header class="text-center mb-8">
            <h1 class="text-3xl md:text-4xl font-bold text-blue-600 mb-2">Ảnh sang Base64 & Chú thích</h1>
            <p class="text-gray-500">Tải ảnh, nén, <span class="text-blue-600 font-semibold">đánh dấu/chú thích</span> và lấy mã nhúng.</p>
        </header>

        <!-- Main Layout -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
            
            <!-- Left Column: Settings & Upload -->
            <div class="lg:col-span-1 space-y-6">
                
                <!-- Upload Card -->
                <div class="bg-white rounded-2xl shadow-sm border border-gray-100 p-6">
                    <div class="flex flex-col items-center justify-center w-full">
                        <label for="dropzone-file" class="flex flex-col items-center justify-center w-full h-32 border-2 border-blue-300 border-dashed rounded-xl cursor-pointer bg-blue-50 hover:bg-blue-100 transition-all duration-300 group">
                            <div class="flex flex-col items-center justify-center pt-5 pb-6">
                                <svg class="w-8 h-8 mb-2 text-blue-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path></svg>
                                <p class="text-sm text-gray-600"><span class="font-bold">Tải ảnh lên</span> (Kéo thả hoặc Dán)</p>
                            </div>
                            <input id="dropzone-file" type="file" class="hidden" accept="image/*" />
                        </label>
                        <p class="text-xs text-gray-400 mt-2">Nhấn Ctrl+V/Cmd+V để dán ảnh từ clipboard.</p>
                    </div>
                </div>

                <!-- Settings Card -->
                <div id="settingsPanel" class="hidden bg-white rounded-2xl shadow-sm border border-gray-100 p-6 space-y-5">
                    <h3 class="font-bold text-gray-700 border-b pb-2">Cấu hình</h3>
                    
                    <!-- Width -->
                    <div>
                        <label class="block mb-1 text-sm font-medium text-gray-700">Chiều rộng (px)</label>
                        <div class="flex gap-2">
                             <input type="number" id="maxWidthInput" class="bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg block w-full p-2" placeholder="Auto">
                             <span class="inline-flex items-center px-2 text-xs text-gray-500 bg-gray-100 rounded border border-gray-200 whitespace-nowrap">
                                 Gốc: <span id="originalWidthDisplay" class="ml-1 font-bold">0</span>
                             </span>
                        </div>
                    </div>

                    <!-- Quality -->
                    <div>
                        <label class="block mb-1 text-sm font-medium text-gray-700 flex justify-between">
                            <span>Chất lượng</span>
                            <span id="qualityValue" class="text-blue-600 font-bold">80%</span>
                        </label>
                        <input id="qualityInput" type="range" value="0.8" min="0.1" max="1" step="0.05" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                    </div>

                    <!-- Format -->
                    <div>
                        <label class="block mb-1 text-sm font-medium text-gray-700">Định dạng</label>
                        <select id="formatInput" class="bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg block w-full p-2">
                            <option value="image/jpeg" selected>JPEG (Nhẹ nhất)</option>
                            <option value="image/png">PNG (Trong suốt)</option>
                            <option value="image/webp">WebP (Hiện đại)</option>
                        </select>
                    </div>

                    <!-- Info Box -->
                    <div class="bg-blue-50 rounded-lg p-3 text-xs space-y-1">
                        <div class="flex justify-between"><span class="text-gray-600">Gốc:</span> <span id="originalSize" class="font-medium">0 KB</span></div>
                        <div class="flex justify-between"><span class="text-gray-600">Base64:</span> <span id="compressedSize" class="font-bold text-blue-600">0 KB</span></div>
                        <div class="flex justify-between pt-1 border-t border-blue-200"><span class="text-gray-600">Hiệu quả:</span> <span id="savings" class="font-bold">0%</span></div>
                    </div>
                </div>
            </div>

            <!-- Right Column: Editor & Preview -->
            <div class="lg:col-span-2 flex flex-col h-full space-y-4">
                
                <!-- Toolbar -->
                <div id="toolbar" class="hidden flex flex-wrap items-center gap-2 bg-white p-2 rounded-xl shadow-sm border border-gray-100">
                    <span class="text-xs font-bold text-gray-400 uppercase px-2 w-full md:w-auto">Công cụ:</span>
                    
                    <button onclick="setTool('none')" id="btn-move" class="tool-btn active p-2 rounded-lg hover:bg-gray-100 text-gray-600 flex items-center gap-1 text-sm border border-transparent" title="Chế độ xem">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path></svg>
                    </button>
                    
                    <div class="w-px h-6 bg-gray-300 mx-1"></div>

                    <button onclick="rotateImage()" class="p-2 rounded-lg hover:bg-gray-100 text-gray-600 flex items-center gap-1 text-sm border border-transparent" title="Xoay ảnh 90°">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h5M20 20h-5v-5M4 20h5M20 4h-5"></path></svg>
                    </button>

                    <button onclick="setTool('pen')" id="btn-pen" class="tool-btn p-2 rounded-lg hover:bg-gray-100 text-gray-600 flex items-center gap-1 text-sm border border-transparent" title="Bút vẽ tự do">
                        <svg class="w-5 h-5 text-red-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z"></path></svg>
                    </button>

                    <button onclick="setTool('rect')" id="btn-rect" class="tool-btn p-2 rounded-lg hover:bg-gray-100 text-gray-600 flex items-center gap-1 text-sm border border-transparent" title="Hình chữ nhật">
                        <svg class="w-5 h-5 text-red-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2z"></path></svg>
                    </button>

                    <!-- NEW: Line -->
                    <button onclick="setTool('line')" id="btn-line" class="tool-btn p-2 rounded-lg hover:bg-gray-100 text-gray-600 flex items-center gap-1 text-sm border border-transparent" title="Đường thẳng">
                        <svg class="w-5 h-5 text-red-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 20L20 4"></path></svg>
                    </button>

                    <!-- NEW: Arrow -->
                    <button onclick="setTool('arrow')" id="btn-arrow" class="tool-btn p-2 rounded-lg hover:bg-gray-100 text-gray-600 flex items-center gap-1 text-sm border border-transparent" title="Mũi tên">
                        <svg class="w-5 h-5 text-red-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 8l4 4m0 0l-4 4m4-4H3"></path></svg>
                    </button>

                    <button onclick="setTool('circle')" id="btn-circle" class="tool-btn p-2 rounded-lg hover:bg-gray-100 text-gray-600 flex items-center gap-1 text-sm border border-transparent" title="Hình tròn">
                        <svg class="w-5 h-5 text-red-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 21a9 9 0 100-18 9 9 0 000 18z"></path></svg>
                    </button>

                    <div class="w-px h-6 bg-gray-300 mx-1"></div>

                    <button onclick="setTool('number')" id="btn-number" class="tool-btn p-2 rounded-lg hover:bg-gray-100 text-gray-600 flex items-center gap-1 text-sm border border-transparent" title="Đánh số thứ tự">
                        <div class="w-5 h-5 bg-blue-600 text-white rounded-full flex items-center justify-center text-xs font-bold">1</div>
                    </button>

                    <div class="w-px h-6 bg-gray-300 mx-1"></div>

                    <button onclick="setTool('redact')" id="btn-redact" class="tool-btn p-2 rounded-lg hover:bg-gray-100 text-gray-600 flex items-center gap-1 text-sm border border-transparent" title="Che thông tin (Đen)">
                        <svg class="w-5 h-5 text-gray-900" fill="currentColor" viewBox="0 0 24 24"><path d="M4 4h16v16H4z"/></svg>
                    </button>

                    <div class="flex-grow"></div>

                    <button onclick="resetDrawing()" class="p-2 rounded-lg hover:bg-yellow-50 text-yellow-700 flex items-center gap-1 text-sm transition-colors" title="Xóa tất cả hình vẽ">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg>
                    </button>
                </div>

                <!-- Canvas Editor Area -->
                <div id="editorArea" class="hidden flex-grow bg-white rounded-2xl shadow-sm border border-gray-200 overflow-hidden relative preview-pattern flex items-center justify-center min-h-[300px]">
                    <div class="relative max-w-full max-h-full overflow-auto" style="max-height: 80vh;">
                         <canvas id="mainCanvas" class="cursor-crosshair shadow-lg"></canvas>
                    </div>
                    
                    <div id="loading" class="absolute inset-0 bg-white/90 z-50 flex flex-col items-center justify-center hidden">
                        <div class="animate-spin rounded-full h-10 w-10 border-b-2 border-blue-600 mb-2"></div>
                        <p class="text-sm text-gray-500">Đang xử lý...</p>
                    </div>

                    <div id="placeholderText" class="absolute text-gray-400 text-center">
                        <p>Chưa có ảnh</p>
                    </div>
                </div>

                <!-- Action Buttons -->
                <div id="actionButtons" class="hidden grid grid-cols-1 md:grid-cols-3 gap-4">
                    <!-- NEW: Copy Image to Clipboard -->
                    <button onclick="copyImageToClipboard()" class="flex items-center justify-center px-4 py-3 bg-green-600 hover:bg-green-700 text-white rounded-xl transition-all shadow-lg hover:shadow-xl text-sm font-bold">
                        <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7v4m0 0v4m0-4h4m-4 0h4m9 4v-4m0 0v4m0-4h4m-4 0h4M16 18H8m8 0a2 2 0 002-2v-4m-2 4a2 2 0 01-2 2H8a2 2 0 01-2-2v-4a2 2 0 012-2h8a2 2 0 012 2v4a2 2 0 01-2 2z"></path></svg>
                        Copy Ảnh
                    </button>
                    <!-- Existing: Copy IMG Tag -->
                    <button onclick="copyImgTag()" class="flex items-center justify-center px-4 py-3 bg-gray-800 hover:bg-gray-900 text-white rounded-xl transition-all shadow-lg hover:shadow-xl text-sm font-bold">
                        <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4"></path></svg>
                        Copy &lt;img&gt;
                    </button>
                    <!-- Existing: Copy Base64 -->
                    <button onclick="copyBase64()" class="flex items-center justify-center px-4 py-3 bg-blue-600 hover:bg-blue-700 text-white rounded-xl transition-all shadow-lg hover:shadow-xl text-sm font-bold">
                        <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 5H6a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2v-1M8 5a2 2 0 002 2h2a2 2 0 002-2M8 5a2 2 0 012-2h2a2 2 0 012 2m0 0h2a2 2 0 012 2v3m2 4H10m0 0l3-3m-3 3l3 3"></path></svg>
                        Copy Base64
                    </button>
                </div>

                <div id="copySuccess" class="hidden fixed bottom-5 left-1/2 transform -translate-x-1/2 bg-gray-800 text-white px-6 py-3 rounded-full shadow-2xl z-50 flex items-center">
                    <svg class="w-5 h-5 mr-2 text-green-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg>
                    Đã sao chép vào bộ nhớ tạm!
                </div>

            </div>
        </div>
    </div>

    <script>
        // DOM Elements
        const fileInput = document.getElementById('dropzone-file');
        const settingsPanel = document.getElementById('settingsPanel');
        const toolbar = document.getElementById('toolbar');
        const editorArea = document.getElementById('editorArea');
        const actionButtons = document.getElementById('actionButtons');
        const placeholderText = document.getElementById('placeholderText');
        const loadingIndicator = document.getElementById('loading');
        const copySuccess = document.getElementById('copySuccess');
        
        // Canvas & Context
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        
        // Inputs
        const inputs = {
            width: document.getElementById('maxWidthInput'),
            quality: document.getElementById('qualityInput'),
            format: document.getElementById('formatInput'),
            qualityDisplay: document.getElementById('qualityValue'),
            origWidth: document.getElementById('originalWidthDisplay'),
            origSize: document.getElementById('originalSize'),
            compSize: document.getElementById('compressedSize'),
            savings: document.getElementById('savings')
        };

        // State
        let state = {
            originalFile: null,
            originalImageObj: null,
            base64: "",
            tool: 'none', // 'none', 'pen', 'rect', 'circle', 'line', 'arrow', 'number', 'redact'
            isDrawing: false,
            startX: 0,
            startY: 0,
            markerCount: 1,
            snapshot: null, // For restoring canvas during shape preview
            currentRotation: 0, // 0, 90, 180, 270 degrees
        };

        // --- Core Logic ---

        function formatBytes(bytes, decimals = 2) {
            if (!+bytes) return '0 Bytes';
            const k = 1024;
            const dm = decimals < 0 ? 0 : decimals;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return `${parseFloat((bytes / Math.pow(k, i)).toFixed(dm))} ${sizes[i]}`;
        }

        // Initialize with file
        fileInput.addEventListener('change', (e) => handleFile(e.target.files[0]));
        
        function handleFile(file) {
            if (!file || !file.type.startsWith('image/')) {
                console.error("File không phải là ảnh hoặc không hợp lệ.");
                return;
            }

            state.originalFile = file;
            
            // Reset state for new file
            state.currentRotation = 0;
            state.markerCount = 1;

            // UI Reset
            settingsPanel.classList.remove('hidden');
            toolbar.classList.remove('hidden');
            editorArea.classList.remove('hidden');
            actionButtons.classList.remove('hidden');
            placeholderText.classList.add('hidden');
            loadingIndicator.classList.remove('hidden');

            inputs.origSize.textContent = formatBytes(file.size);
            inputs.width.value = ""; // Reset width override

            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    state.originalImageObj = img;
                    inputs.origWidth.textContent = img.width;
                    if (!inputs.width.value) inputs.width.value = Math.min(img.width, 1000); 
                    
                    renderCanvas(); // Initial render
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        // Render Image to Canvas (Resizing & Rotation happens here)
        function renderCanvas() {
            if (!state.originalImageObj) return;
            loadingIndicator.classList.remove('hidden');
            state.markerCount = 1; // Reset markers on reload/resize
            
            // 1. Calculate Scaled Dimensions (based on unrotated image)
            const origW = state.originalImageObj.width;
            const origH = state.originalImageObj.height;
            const maxW = parseInt(inputs.width.value) || origW;
            
            let targetW = origW;
            let targetH = origH;

            if (targetW > maxW) {
                targetH = Math.round((origH * maxW) / origW);
                targetW = maxW;
            }

            // 2. Determine Final Canvas Size based on Rotation
            let finalW = targetW;
            let finalH = targetH;
            
            if (state.currentRotation === 90 || state.currentRotation === 270) {
                finalW = targetH;
                finalH = targetW;
            }

            canvas.width = finalW;
            canvas.height = finalH;

            // 3. Draw Background (White for JPEG transparency fix)
            if (inputs.format.value === 'image/jpeg') {
                ctx.fillStyle = "#FFFFFF";
                ctx.fillRect(0, 0, finalW, finalH);
            } else {
                ctx.clearRect(0, 0, finalW, finalH);
            }

            // 4. Apply Rotation Transformation
            ctx.save();
            ctx.translate(finalW / 2, finalH / 2);
            ctx.rotate(state.currentRotation * Math.PI / 180);

            // 5. Draw Image (using unrotated scaled dimensions, centered)
            ctx.drawImage(state.originalImageObj, -targetW / 2, -targetH / 2, targetW, targetH);
            
            ctx.restore();
            
            updateBase64();
            loadingIndicator.classList.add('hidden');
        }

        function rotateImage() {
            if (!state.originalImageObj) return;
            
            // Xoay 90 độ
            state.currentRotation = (state.currentRotation + 90) % 360;
            
            // Reset nét vẽ vì tọa độ đã thay đổi
            state.markerCount = 1; 
            renderCanvas();
            showSuccess('Đã xoay ảnh 90°. (Nét vẽ cũ đã được xoá.)', 'text-yellow-400');
        }


        // Generate Base64 from current Canvas state
        function updateBase64() {
            const quality = parseFloat(inputs.quality.value);
            state.base64 = canvas.toDataURL(inputs.format.value, quality);
            
            // Stats
            const b64Len = state.base64.length;
            inputs.compSize.textContent = formatBytes(b64Len);
            
            const origBytes = state.originalFile.size;
            const diff = b64Len - origBytes;
            const pct = (diff / origBytes) * 100;
            
            if (diff > 0) {
                inputs.savings.textContent = `+${pct.toFixed(1)}%`;
                inputs.savings.className = "font-bold text-red-500";
            } else {
                inputs.savings.textContent = `${pct.toFixed(1)}%`;
                inputs.savings.className = "font-bold text-green-600";
            }
        }
        
        // Helper function to draw an arrow head
        function drawArrow(context, fromX, fromY, toX, toY, headLength) {
            headLength = headLength || 15; // Increased head length for clarity
            const angle = Math.atan2(toY - fromY, toX - fromX);
            
            context.beginPath();
            context.moveTo(fromX, fromY);
            context.lineTo(toX, toY);
            
            // Draw arrowhead (two lines forming a V-shape)
            context.moveTo(toX, toY);
            // Line 1 of the head
            context.lineTo(
                toX - headLength * Math.cos(angle - Math.PI / 6),
                toY - headLength * Math.sin(angle - Math.PI / 6)
            );
            context.moveTo(toX, toY);
            // Line 2 of the head
            context.lineTo(
                toX - headLength * Math.cos(angle + Math.PI / 6),
                toY - headLength * Math.sin(angle + Math.PI / 6)
            );
            context.stroke();
        }


        // --- Drawing Logic ---

        function setTool(toolName) {
            state.tool = toolName;
            
            // Update UI
            document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
            const btnId = 'btn-' + toolName;
            const btn = document.getElementById(btnId);
            if(btn) btn.classList.add('active');

            // Cursor
            canvas.style.cursor = toolName === 'none' ? 'default' : 'crosshair';
        }

        function getPos(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            let clientX = e.clientX;
            let clientY = e.clientY;

            // Touch support
            if (e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            }

            return {
                x: (clientX - rect.left) * scaleX,
                y: (clientY - rect.top) * scaleY
            };
        }

        function startDrawing(e) {
            if (state.tool === 'none') return;
            e.preventDefault();
            
            const pos = getPos(e);
            state.startX = pos.x;
            state.startY = pos.y;

            // Handle Number Marker Click separately (no drag needed)
            if (state.tool === 'number') {
                drawMarker(pos.x, pos.y, state.markerCount++);
                updateBase64();
                return;
            }

            state.isDrawing = true;

            // Save snapshot for shapes (rect/circle/line/arrow) to enable preview
            if (['rect', 'circle', 'line', 'arrow'].includes(state.tool)) {
                state.snapshot = ctx.getImageData(0, 0, canvas.width, canvas.height);
            } else {
                // For pen/redact, start path
                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y);
            }
            
            // For Pen/Redact single dot
            if(state.tool === 'pen' || state.tool === 'redact') {
                draw(e); 
            }
        }

        function draw(e) {
            if (!state.isDrawing) return;
            e.preventDefault(); 
            
            const pos = getPos(e);
            
            if (state.tool === 'pen') {
                ctx.lineWidth = 3;
                ctx.lineCap = "round";
                ctx.lineJoin = "round";
                ctx.strokeStyle = "rgba(239, 68, 68, 0.9)"; // Red
                ctx.lineTo(pos.x, pos.y);
                ctx.stroke();
            } 
            else if (state.tool === 'redact') {
                ctx.lineWidth = 15;
                ctx.lineCap = "round";
                ctx.lineJoin = "round";
                ctx.strokeStyle = "#000000"; // Black
                ctx.lineTo(pos.x, pos.y);
                ctx.stroke();
            }
            else if (['rect', 'circle', 'line', 'arrow'].includes(state.tool)) {
                // Restore original state to clear previous preview frame
                ctx.putImageData(state.snapshot, 0, 0);
                
                ctx.lineWidth = 3;
                ctx.strokeStyle = "rgba(239, 68, 68, 0.9)"; // Red
                ctx.lineCap = "round";
                ctx.lineJoin = "round";

                let currentX = pos.x;
                let currentY = pos.y;

                if (state.tool === 'rect') {
                    let w = currentX - state.startX;
                    let h = currentY - state.startY;
                    ctx.strokeRect(state.startX, state.startY, w, h);
                } else if (state.tool === 'circle') {
                    // Draw ellipse/circle based on drag
                    ctx.beginPath();
                    let radiusX = Math.abs(currentX - state.startX) / 2;
                    let radiusY = Math.abs(currentY - state.startY) / 2;
                    let centerX = state.startX + (currentX - state.startX) / 2;
                    let centerY = state.startY + (currentY - state.startY) / 2;
                    ctx.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, 2 * Math.PI);
                    ctx.stroke();
                } else if (state.tool === 'line') {
                    ctx.beginPath();
                    ctx.moveTo(state.startX, state.startY);
                    ctx.lineTo(currentX, currentY);
                    ctx.stroke();
                } else if (state.tool === 'arrow') {
                    drawArrow(ctx, state.startX, state.startY, currentX, currentY, 15);
                }
            }
        }

        function stopDrawing() {
            if (state.isDrawing) {
                state.isDrawing = false;
                updateBase64(); // Update result after action
            }
        }

        function drawMarker(x, y, number) {
            const size = 24; // Circle diameter
            
            ctx.beginPath();
            ctx.arc(x, y, size/2, 0, 2 * Math.PI, false);
            ctx.fillStyle = '#2563eb'; // Blue-600
            ctx.fill();
            ctx.lineWidth = 2;
            ctx.strokeStyle = '#ffffff';
            ctx.stroke();

            ctx.font = 'bold 12px sans-serif';
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(number, x, y + 1); // +1 for visual center adjustment
        }

        // Event Listeners for Canvas
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseout', stopDrawing);

        // Touch Events
        canvas.addEventListener('touchstart', startDrawing, {passive: false});
        canvas.addEventListener('touchmove', draw, {passive: false});
        canvas.addEventListener('touchend', stopDrawing);

        function resetDrawing() {
            if (confirm("Thao tác này sẽ xóa mọi nét vẽ. Bạn có chắc không?")) {
                renderCanvas();
            }
        }

        // --- Settings Events ---
        inputs.width.addEventListener('change', () => renderCanvas()); 
        inputs.format.addEventListener('change', () => renderCanvas()); 
        
        inputs.quality.addEventListener('input', () => {
            inputs.qualityDisplay.textContent = Math.round(inputs.quality.value * 100) + '%';
            updateBase64(); 
        });

        // --- Clipboard & Copy Utils ---
        function showSuccess(message = 'Đã sao chép vào bộ nhớ tạm!', colorClass = 'text-green-400') {
            copySuccess.textContent = message;
            // Find the SVG element inside the copySuccess div
            const svgEl = copySuccess.querySelector('svg');
            if (svgEl) {
                svgEl.className = `w-5 h-5 mr-2 ${colorClass}`;
            }
            copySuccess.classList.remove('hidden');
            copySuccess.classList.add('animate-bounce');
            setTimeout(() => {
                copySuccess.classList.add('hidden');
                copySuccess.classList.remove('animate-bounce');
            }, 2500);
        }

        function copyBase64() {
            if (!state.base64) return;
            navigator.clipboard.writeText(state.base64).then(() => showSuccess('Đã copy mã Base64!'));
        }

        function copyImgTag() {
            if (!state.base64) return;
            const tag = `<img src="${state.base64}" alt="Base64 Image" />`;
            navigator.clipboard.writeText(tag).then(() => showSuccess('Đã copy thẻ <img>!'));
        }

        // NEW: Copy Image to Clipboard
        function copyImageToClipboard() {
            if (!state.originalImageObj) return;

            // Check for modern clipboard API support
            if (typeof navigator.clipboard.write !== 'function' || typeof ClipboardItem === 'undefined') {
                showSuccess('Lỗi: Trình duyệt không hỗ trợ sao chép ảnh trực tiếp.', 'text-red-500');
                return;
            }

            loadingIndicator.classList.remove('hidden');
            
            // Get Blob from Canvas
            canvas.toBlob(function(blob) {
                loadingIndicator.classList.add('hidden');
                if (!blob) {
                    showSuccess('Lỗi: Không thể tạo ảnh Blob.', 'text-red-500');
                    return;
                }
                
                // Write Blob as ClipboardItem
                const item = new ClipboardItem({ [blob.type]: blob });
                navigator.clipboard.write([item]).then(function() {
                    showSuccess('Đã sao chép ảnh vào clipboard!');
                }, function(err) {
                    console.error('Error copying image: ', err);
                    showSuccess('Lỗi: Thất bại khi sao chép ảnh.', 'text-red-500');
                });
            }, inputs.format.value, parseFloat(inputs.quality.value));
        }

        // NEW: Paste Image from Clipboard
        document.addEventListener('paste', handlePaste);

        function handlePaste(e) {
            const items = e.clipboardData.items;
            let imageFound = false;

            for (let i = 0; i < items.length; i++) {
                if (items[i].type.indexOf('image') !== -1) {
                    const blob = items[i].getAsFile();
                    if (blob) {
                        e.preventDefault(); // Stop default paste action
                        handleFile(blob);
                        imageFound = true;
                        break;
                    }
                }
            }
            
            if (imageFound) {
                 showSuccess('Đã dán ảnh từ clipboard!');
            }
        }

        // --- Drag & Drop ---
        const dropZone = document.querySelector('label[for="dropzone-file"]');
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, (e) => {
                e.preventDefault();
                e.stopPropagation();
            }, false);
        });
        dropZone.addEventListener('drop', (e) => {
            if (e.dataTransfer.files && e.dataTransfer.files[0]) {
                handleFile(e.dataTransfer.files[0]);
            }
        });

    </script>
</body>
</html>
